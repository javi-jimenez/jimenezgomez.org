<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Software on Francisco Javier Jiménez Gómez</title>
        <link>https://jimenezgomez.org/categories/software/</link>
        <description>Recent content in Software on Francisco Javier Jiménez Gómez</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>es</language>
        <copyright>Francisco Javier Jiménez Gómez</copyright>
        <lastBuildDate>Sun, 31 Mar 2024 20:52:00 +0200</lastBuildDate><atom:link href="https://jimenezgomez.org/categories/software/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Three layers abstraction</title>
        <link>https://jimenezgomez.org/posts/2024-03-31-three-layers-abstraction/</link>
        <pubDate>Sun, 31 Mar 2024 20:52:00 +0200</pubDate>
        
        <guid>https://jimenezgomez.org/posts/2024-03-31-three-layers-abstraction/</guid>
        <description>&lt;p&gt;&lt;img src=&#34;https://jimenezgomez.org/posts/2024-03-31-three-layers-abstraction/three-layers-as-leafs-gettyimages-1000px-157287379-2048x2048.jpg&#34;
	width=&#34;1000&#34;
	height=&#34;667&#34;
	srcset=&#34;https://jimenezgomez.org/posts/2024-03-31-three-layers-abstraction/three-layers-as-leafs-gettyimages-1000px-157287379-2048x2048_hu_e10b507ce78069a5.jpg 480w, https://jimenezgomez.org/posts/2024-03-31-three-layers-abstraction/three-layers-as-leafs-gettyimages-1000px-157287379-2048x2048_hu_9afc46b1fd8fc6be.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Three Layers as Leafs&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;149&#34;
		data-flex-basis=&#34;359px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;The software design can be simplified in three layers:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;View&lt;/li&gt;
&lt;li&gt;Business&lt;/li&gt;
&lt;li&gt;Data&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For example, in a web application, you have:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;View, usually in JavaScript, HTML and CSS&lt;/li&gt;
&lt;li&gt;Business, usually JavaScript or a backend API&lt;/li&gt;
&lt;li&gt;Data, the pure data, that can be structured data as a database or a dictionary, for example&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If we want to stablish a relation between layers and Fractal Architecture, we can view the previous Business layer as composed of three layers:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;View, the backend API&lt;/li&gt;
&lt;li&gt;Business, the Domain&lt;/li&gt;
&lt;li&gt;Data, the objects that represent the underlying data&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the initial decomposition, the Data layer can be seen again as a three layer design:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;View, the accepted commands and the REPL or API&lt;/li&gt;
&lt;li&gt;Business, the internal logic or the database application&lt;/li&gt;
&lt;li&gt;Data, the internal structures used by the application to effectively store the data&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As you see, you can extend the concept to other domains.&lt;/p&gt;
&lt;p&gt;This brief idea can be of help when we design or think about architecture.&lt;/p&gt;
&lt;p&gt;Finally, to fit this idea into the Fractal Architecture, all three (or any you have) layers, must be considered as an atomic autonomous block with an input and an output, as a black box pattern.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>VBD, Fractal Architecture: View, Business and Data. Input and Output.</title>
        <link>https://jimenezgomez.org/posts/2024-03-31-vbd-fractal-architecture-view-business-and-data-input-and-output/</link>
        <pubDate>Sun, 31 Mar 2024 20:44:00 +0200</pubDate>
        
        <guid>https://jimenezgomez.org/posts/2024-03-31-vbd-fractal-architecture-view-business-and-data-input-and-output/</guid>
        <description>&lt;meta property=&#34;og:image&#34; content=&#34;2024-03-31-vbd-fractal-architecture-view-business-and-data-input-and-output/fractal-maldelbrot-illustration-1000px-gettyimages-488635425-2048x2048.jpg&#34; /&gt;
&lt;meta name=&#34;twitter:image&#34; content=&#34;2024-03-31-vbd-fractal-architecture-view-business-and-data-input-and-output/fractal-maldelbrot-illustration-1000px-gettyimages-488635425-2048x2048.jpg&#34; /&gt;
&lt;p&gt;&lt;img src=&#34;https://jimenezgomez.org/posts/2024-03-31-vbd-fractal-architecture-view-business-and-data-input-and-output/fractal-maldelbrot-illustration-1000px-gettyimages-488635425-2048x2048.jpg&#34;
	width=&#34;1000&#34;
	height=&#34;750&#34;
	srcset=&#34;https://jimenezgomez.org/posts/2024-03-31-vbd-fractal-architecture-view-business-and-data-input-and-output/fractal-maldelbrot-illustration-1000px-gettyimages-488635425-2048x2048_hu_71538f2550c6dc83.jpg 480w, https://jimenezgomez.org/posts/2024-03-31-vbd-fractal-architecture-view-business-and-data-input-and-output/fractal-maldelbrot-illustration-1000px-gettyimages-488635425-2048x2048_hu_50dd66516025c0b2.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Maldelbrot set&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;133&#34;
		data-flex-basis=&#34;320px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;One of the main purpose of a computer system is to process data.&lt;/p&gt;
&lt;p&gt;And the principle: data travels between services.&lt;/p&gt;
&lt;p&gt;Applications have an input and an output:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Input, the application receives data&lt;/li&gt;
&lt;li&gt;Internally the application process data&lt;/li&gt;
&lt;li&gt;Output, after processing the data, the application produces an output.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With this pattern, applications can be reduced to software that does input and produces output.&lt;/p&gt;
&lt;p&gt;You are doing Fractal Architecture when you link the services, then you have a bigger system, sure, thats reasoning is trivial, but with this, your new system can be seen as an autonomous system. And that new system can be used in another bigger systems.&lt;/p&gt;
&lt;p&gt;That can be replicated as in fractals, if you zoom, you see the same pattern over and over again.&lt;/p&gt;
&lt;p&gt;If you try to extract that pattern from designs, you will find that it is usually repeated. This is related to Fractal Architecture.&lt;/p&gt;
&lt;p&gt;If you see this from an holistic point of view, and you put the best effort in your application, with one specific and well designed functionallity, this lead us to a basic design principle: do one thing and do it well, as in the unix-like world.&lt;/p&gt;
&lt;p&gt;This has deep implications in microservices, in the case where you design an autonomous service, for a single task and you put a lot of effort in doing that task really well.&lt;/p&gt;
&lt;p&gt;You can then link microservices between them, using an orchestrator or not, the key point is to have services that do one task and do it well.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Monoliths and microservices</title>
        <link>https://jimenezgomez.org/posts/2023-12-24-monoliths-and-microservices/</link>
        <pubDate>Sun, 24 Dec 2023 00:00:00 +0200</pubDate>
        
        <guid>https://jimenezgomez.org/posts/2023-12-24-monoliths-and-microservices/</guid>
        <description>&lt;!-- preview image on social media --&gt;
&lt;meta property=&#34;og:image&#34; content=&#34;2023-12-24-monoliths-and-microservices/inca-bricks-1000px.jpg&#34; /&gt;
&lt;p&gt;&lt;img src=&#34;https://jimenezgomez.org/posts/2023-12-24-monoliths-and-microservices/inca-bricks-1000px.jpg&#34;
	width=&#34;1000&#34;
	height=&#34;1005&#34;
	srcset=&#34;https://jimenezgomez.org/posts/2023-12-24-monoliths-and-microservices/inca-bricks-1000px_hu_4ba43dc18399bd24.jpg 480w, https://jimenezgomez.org/posts/2023-12-24-monoliths-and-microservices/inca-bricks-1000px_hu_cc9f36dc5358d227.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Monoliths and MicroServices&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;99&#34;
		data-flex-basis=&#34;238px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;Monoliths are the first approach to an application build.&lt;/p&gt;
&lt;p&gt;Microservices are the refinement and the evolution of monoliths.&lt;/p&gt;
&lt;p&gt;If the system is designed carefuly from the begining, a system composed of microservices can be built. But the base is always a monolith, not as complex as some final products that must be converted to microservices.&lt;/p&gt;
&lt;p&gt;Commonly, a monolith is a big microservice, that is, a complex system that must be divided or splitted into parts to manage it properly.&lt;/p&gt;
&lt;p&gt;It happens the same as with files that compose an application, which have a lot of methods or are very complex, the recommendation is to reduce the size and complexity of the file. By that reason, big files and big applications, share the same principle (problem), complexity.&lt;/p&gt;
&lt;p&gt;Microservices allow to reduce complexity, between other things.&lt;/p&gt;
&lt;p&gt;A system composed with microservices and a monolith are, almost the same. The monolith calls to other funcionalities are made using libraries, the calls in a system composed by microservices are made using message queues, but in essence, it is the same.&lt;/p&gt;
&lt;p&gt;The only difference is the way to call methods, or better said, to call funcionality.&lt;/p&gt;
&lt;p&gt;Abstracting the concept, we can write an application that call to methods, but internally it is calling to other remote services, that has been doing from time ago.&lt;/p&gt;
&lt;p&gt;If you want to center your efforts in architecture, you can design services that can be used to compose multiple big systems. That will allow you to think in sharing functionality. You must center your efforts in functionality, and you must design and build the minimal autonomous system. That minimal autonomous system must be perfected and reused. Microservices, with remote calls, ease this, in relation to distributing systems, but the diagram must be the same as with monoliths.&lt;/p&gt;
&lt;p&gt;The base for reusing funcionality, modules, services or whatever is to build the minimal functionality in one module, an autonomous system.&lt;/p&gt;
&lt;p&gt;The diagram in a monolith or a microservice must be the same, the only change is the way calls are made. You must abstract it the most you can to get that.&lt;/p&gt;
&lt;p&gt;A requirement for making autonomous systems is to develop based on the use of interfaces. Today we know API, which is the same idea. A public face to the world.&lt;/p&gt;
&lt;p&gt;As a final note I must to say that you must to specify the ADT or Abstract Data Type or your internal data structures, the allowed input and the allowed or expected output.&lt;/p&gt;
&lt;p&gt;And as another useful tip: An interesting standarization of Abstract Data Types is the project schema.org, which contains vocabularies for including and standarize those data types. For example, you know what to expect when working with a postal address, it has a postal code, it is a street or other type of place, and similar things. With that, when you receive an Address compliant with schema.org, you know what the names of the fields are and which is the meaning of each field.&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
